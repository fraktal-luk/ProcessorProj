
Scalar pipeline

At the beginning is IP/PC with instruction address. Based on it, a word from ICache is read in 1 cycle.

[IP] -> Fetch -> Decode -> Rename -> Issue -> {Exec0 .. ExecN} -> Commit -> Update

Control signals needed by each stage or set by them:
Of course every one of them needs basic pipe control signals, but also some specific state variables.

Some signals can be driven by multiple stages, and need priority arbitration!

#Fetch: output of ICache is treated as part of output of this stage
inputs:
	IP
	fetchCtrInc
outputs:
	update IP
	update fetchCtr
	
#Decode
inputs:
	-
outputs:	
	? branch speculation
	
#Rename
inputs: info about renamed regs
	physical arg description (Dependent output from Decode!)
	newRegTag	
outputs:
	update virt desc
	update phys desc
	update free list
	update reg tag
		> outputs for contact with renaming engine:
		- virtual reg info

#Issue		
inputs:
	physical reg read ports (3)
	input from forw. network? - because when stalled, maybe newly available args must be filled before they go to registers; but maybe reading from regs is also possible,
					cause it's done at this very stage anyway? Probably it has to be possible, cause why not read PRs just because the stage is not moving?
outputs:	
	addresses of phys regs for reading
	selection for forw. network?
	
// 	
#Exec(k):  	
inputs: 
	input from forw. network - maybe needed individual for each Exec stage?	
outputs: 
	selection for forw. network?
	? branch resolution, exception alert 
	sets forw. content info
	
#Commit:  does little by itself, most is done actually by JumpControl
inputs:
	? if comitCandidate is he iutput, then all final Exec stages have inputs into this, but it's in the pipeline structure itself
outputs:
	sets forw. content info
	? commitCandidate can be considered an output from this?
	
> JumpControl: contains shared data, like IP, fetchCtr etc.
inputs: (everyth. that is side output from pipe stages)
	commitCandidate
	? interrupt signal + interrupt handler address (and additional info?)
	
outputs:	
	[defined in CommitAction struct]
	....
	

>> What handles conviction propagation? It can ge tmore complex when exception alerts, branch info etc. can be sent from different stages!
	
	
	