Instruction struct
{
//! info about level (is it from interrupt, what level of //it, etc.. exc handler?...)
threadInfo  (??)
{	// This is known before fetching (??) and constant
	IP (address)
	- thread number (if multithreading implementation)
	level (int level?)
	privilege level -- or should it be global state??
	is exc. handler?
}

controlInfo: mutable
{	// updated at various stages
	exception?
	exc. code
	branch? 
	b. speculated?
	b. confirmed? 
	(b. address)??
	...?
}

insWord  // F - actual bits of command (from Fetch)

operation 	// D
{
	unit
	func
}

systemInfo // D
{
	fetch lock?
	change control regs?
	needs privilege? what level?
	...
}

constArgs	 // D
logicalArgs // D
logicalDest // D

physArgs	// R
physDest	// R

	argValues	// I, ...

numberTag  // R?
regTag	// R

result	// E

}

-----------------------------------------------------------------
# Scenarios

Action types:
-nothing
-normal instr
-sleep instr
-jump
-return from exc/int
-system call
-exception
-interrupt
-wake up

Control signals:
-enable
- (?) newInsReady
-halt ?
-int (levels...)


...........................
Issue queues:

[1][ ][ ]
- 1 input
- an item in the list is sent to Exec or to next slot or stalled
- if new op written to queue and first slot is occupied, the content has to move to free the first place 
- slot that is being freed by op going to Exec stays empty if no writes to the queue
- the remaining empty space gets filled when instructions move to allow wrting a new one
- issue is possible from every slot
- it follows that writing is forbidden when all slots full and nothing goes to Exec
- if more than 1 issue possible, prefer the front of queue (oldest stored because the order in the queue is not mixed)

Commit queue:
- k inputs, writing possible at each one, but each one is waiting for a proper instruction
- 1 output (in scalar version)
- when output slots are full, their content is written to commit and the rest moves forward
- inputs are blocked if their slots are full and not being effectively freed


Storage queue:
- input to each slot
- 1 output
- writing to successive slots
- if reading from output, everything moves forward and writing is to the last full slot

...........................
Test sequences
@
> Nothing
> Continuous stream of instructions
> Normal ins stream with newInsReady on/off
> ... with jump 
> ... with multiple jumps, some in sequence
	- older jumps detected after younger jumps
> ... with exception
> ... with multiple exceptions
	- older excpetions detected after younger
> ... as above, with jumps and exceptions, 

@ Interrupts at different moments during previous scenarios

..........................










